<!DOCTYPE html>
<html lang="ml">
<head>
  <meta charset="UTF-8">
  <title>KSEB Prosumer Bill Calculator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Malayalam&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Noto Sans Malayalam', Arial, sans-serif;
      margin: 1rem;
      background: #f7f7f7;
    }

    h1 {
      color: #1e88e5;
      font-size: 1.5rem;
      text-align: center;
    }

    form {
      max-width: 600px;
      margin: 0 auto;
    }

    input, select, button {
      padding: 0.5rem;
      margin: 0.5rem 0;
      width: 100%;
      box-sizing: border-box;
      font-size: 1rem;
    }

    .result {
      background: #e3f2fd;
      padding: 1rem;
      margin-top: 1rem;
      border-left: 5px solid #1e88e5;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }

    .timestamp {
      font-size: 0.9rem;
      color: #555;
      text-align: center;
      margin-bottom: 1rem;
    }

    .hidden {
      display: none;
    }

    .debug {
      background: #fff8dc;
      color: #333;
      font-family: monospace;
      white-space: pre-wrap;
      border: 1px dashed #aaa;
      padding: 1rem;
      margin-top: 1rem;
    }

    #downloadFullPDF {
      display: block;
      margin: 1rem auto;
      padding: 0.75rem;
      font-size: 1rem;
      background: #1e88e5;
      color: white;
      border: none;
      border-radius: 5px;
    }

    @media print {
      #billForm, #downloadFullPDF, .timestamp, #debugPanel {
        display: none;
      }
      .result {
        display: block !important;
      }
    }
  </style>
</head>
<body>

<div id="pdfContent">
  <h1>KSEB Prosumer Bill Calculator<br><span style="font-size: 1rem;">കെ.എസ്.ഇ.ബി. പ്രോസ്യൂമർ ബിൽ കാൽക്കുലേറ്റർ</span></h1>
  <div class="timestamp" id="timestamp"></div>

  <form id="billForm">

    <label>Connection Type / കണക്ഷൻ തരം:</label>
    <select id="connectionType">
      <option value="LT1">LT-1 Domestic / ഡൊമസ്റ്റിക്</option>
    </select>

    <label>Phase Type / ഫേസ് തരം:</label>
    <select id="phaseType">
      <option value="single">Single Phase / സിംഗിൾ ഫേസ്</option>
      <option value="three">Three Phase / ത്രിഫേസ്</option>
    </select>

    <label>Units Imported from Grid [I] / ഗ്രിഡിൽ നിന്നുള്ള ഇംപോർട്ട്:</label>
    <input type="number" id="importUnits" required>

    <label>Units Exported to Grid [E] / ഗ്രിഡിലേക്ക് അയച്ച യൂണിറ്റുകൾ:</label>
    <input type="number" id="exportUnits" required>

    <label>Total Solar Energy Generation [EG] / മൊത്തം സോളാർ ഊർജം:</label>
    <input type="number" id="Solar" value="0">

    <div id="todFields" class="hidden">
      <label>Day Units (D) / ദിന സമയ ഉപഭോഗം:</label>
      <input type="number" id="todDay">

      <label>Peak Units (P) / പീക്ക് ടൈം ഉപഭോഗം:</label>
      <input type="number" id="todPeak">

      <label>Off-Peak Units (OP) / ഓഫ്-പീക്ക് ഉപഭോഗം:</label>
      <input type="number" id="todOffpeak">
    </div>

    <button type="submit">Calculate / കാൽക്കുലേറ്റ് ചെയ്യുക</button>
  </form>

  <div class="result" id="result" style="display: none;"></div>
  <div id="debugPanel" class="debug hidden"></div>
</div>

<button id="downloadFullPDF">Download Full Page as PDF</button>

<script>
// Insert timestamp
const now = new Date();
document.getElementById('timestamp').textContent = `Date: ${now.toLocaleDateString()} | Time: ${now.toLocaleTimeString()}`;

let slabs = [], charges = {}, todRates = {}, fixedChargeTable = [];
let meterChargeTable = [];
let isTOD = false, todBaseRate = 0, totalImport = 0;

let debugLog = [];


function showDebugPanel() {
  const panel = document.getElementById('debugPanel');
  panel.classList.remove('hidden');
  panel.textContent = debugLog.join('\n');
}

function loadCSV(file, parser) {
  return fetch(file)
    .then(res => res.ok ? res.text() : Promise.reject(`Failed to load ${file}`))
    .then(text => {
      parser(text);
      debugLog.push(`[LOADED] ${file}`);
    })
    .catch(error => {
      console.error(`[CSV ERROR] ${file}:`, error);
      debugLog.push(`[ERROR] ${error}`);
    });
}

function parseSlabs(text) {
  const lines = text.trim().split('\n').slice(1);
  slabs = lines.map(line => {
    const [range, rate] = line.split(',');
    const upper = parseInt(range.split('-')[1] || range.match(/\d+/g)?.[0]) || 0;
    return { limit: upper, rate: parseFloat(rate) };
  });
  debugLog.push(`Parsed Slabs: ${JSON.stringify(slabs)}`);
}

function parseTODRates(text) {
  const lines = text.trim().split('\n').slice(1);
  todRates = {};
  lines.forEach(line => {
    const [label, rate] = line.split(',');
    todRates[label.trim().toLowerCase()] = parseFloat(rate);
  });
  debugLog.push(`TOD Rates: ${JSON.stringify(todRates)}`);
}

function parseTODTariff(text) {
  const lines = text.trim().split('\n').slice(1);
  for (let line of lines) {
    const [range, base] = line.split(',');
    const upper = /above/i.test(range) ? Infinity : parseInt(range.match(/\d+/g)?.[0]) || 0;
    if (totalImport <= upper) {
      todBaseRate = parseFloat(base);
      break;
    }
  }
  debugLog.push(`TOD Base Rate: ${todBaseRate}`);
}

function parseCharges(text) {
  const lines = text.trim().split('\n').slice(1);
  charges = {};
  lines.forEach(line => {
    const [key, value] = line.split(',');
    charges[key.trim()] = parseFloat(value.trim());
  });
  debugLog.push(`Charges: ${JSON.stringify(charges)}`);
}

function parseFixedCharges(text) {
  const lines = text.trim().split('\n').slice(1);
  fixedChargeTable = lines.map(line => {
    const [slab, single, three] = line.split(',');
    let min = 0, max = Infinity;
    if (slab.includes('-')) {
      [min, max] = slab.split('-').map(Number);
    } else if (/above/i.test(slab)) {
      min = parseInt(slab.match(/\d+/)?.[0]) || 0;
    }
    return { min, max, label: slab.trim(), single: parseFloat(single), three: parseFloat(three) };
  });
  debugLog.push(`Fixed Charges: ${JSON.stringify(fixedChargeTable)}`);
}

function parseMeterCharges(text) {
  const lines = text.trim().split('\n').slice(1);
  meterChargeTable = lines.map(line => {
    const [type, single, three] = line.split(',');
    return {
      label: type.trim(),
      single: parseFloat(single),
      three: parseFloat(three)
    };
  });
  debugLog.push(`Meter Charges: ${JSON.stringify(meterChargeTable)}`);
}

function getFixedCharge(phaseType, totalUnits) {
  for (let row of fixedChargeTable) {
    if (totalUnits > row.min && totalUnits <= row.max) {
      return {
        value: phaseType === 'three' ? row.three : row.single,
        label: row.label
      };
    }
  }
  return { value: 0, label: 'Not found' };
}

function getMeterRent(connectionType, phaseType) {
  for (let row of meterChargeTable) {
    if (row.label === connectionType) {
      const value = phaseType === 'three' ? row.three : row.single;
      const label = `${row.label}-${phaseType}`;
      return {
        value,
        label
      };
    }
  }
  return { value: 0, label: 'Not found' };
}



function calculateDomesticCharge(units) {
  let total = 0, prevLimit = 0;
  for (let i = 0; i < slabs.length && units > 0; i++) {
    const slab = slabs[i];
    const slabUnits = Math.min(units, slab.limit - prevLimit);
    total += slabUnits * slab.rate;
    units -= slabUnits;
    prevLimit = slab.limit;
  }
  return total;
}

function calculateTODCharge(day, peak, offpeak) {
  return todBaseRate * (
    (day * todRates.d) +
    (peak * todRates.p) +
    (offpeak * todRates.op)
  );
}


function calculateDomesticChargeString(units) {
  let total = 0, prevLimit = 0;
  const parts = [];

  for (let i = 0; i < slabs.length && units > 0; i++) {
    const slab = slabs[i];
    const slabUnits = Math.min(units, slab.limit - prevLimit);
    const charge = slabUnits * slab.rate;

    parts.push(`${slabUnits} units * ₹${slab.rate.toFixed(2)} = ₹${charge.toFixed(2)}`);

    total += charge;
    units -= slabUnits;
    prevLimit = slab.limit;
  }

  return parts.join(' + ');
}

function getTODCalculationString(day, peak, offpeak) {
  const parts = [];
  if (day > 0) parts.push(`D ${day} * ₹${todBaseRate} * ${todRates.d} = ₹${(day * todBaseRate * todRates.d).toFixed(2)}`);
  if (offpeak > 0) parts.push(`OP ${offpeak} * ₹${todBaseRate} * ${todRates.op} = ₹${(offpeak * todBaseRate * todRates.op).toFixed(2)}`);
  if (peak > 0) parts.push(`P ${peak} * ₹${todBaseRate} * ${todRates.p} = ₹${(peak * todBaseRate * todRates.p).toFixed(2)}`);
  return parts.join(' + ');
}

function getFixedChargeString(importUnits, ownSolarDay) {
  const total = importUnits + ownSolarDay;
  return `I:${importUnits}+OC:${ownSolarDay}=${total}`;
}





function getFixedChargeString(importUnits, ownSolarDay) {
  const total = importUnits + ownSolarDay;
  return `I:${importUnits}+OC:${ownSolarDay}=${total}`;
}

// Existing functions for parseSlabs, parseTODRates, parseTODTariff, parseCharges, parseFixedCharges, parseMeterCharges, etc. remain unchanged

function getMeterRent(connectionType, phaseType) {
  for (let row of meterChargeTable) {
    if (row.label === connectionType) {
      const value = phaseType === 'three' ? row.three : row.single;
      const label = `${row.label}-${phaseType}`;
      return { value, label };
    }
  }
  return { value: 0, label: 'Not found' };
}

async function setupBilling(importUnits) {
  totalImport = importUnits;
  await loadCSV('fixed_charge.csv', parseFixedCharges);
  await loadCSV('meter_charges.csv', parseMeterCharges);

  if (importUnits > 250) {
    isTOD = true;
    document.getElementById('todFields').classList.remove('hidden');
    await Promise.all([
      loadCSV('tariff_tod_base.csv', parseTODTariff),
      loadCSV('tariff_tod.csv', parseTODRates),
      loadCSV('charges_tod.csv', parseCharges)
    ]);
  } else {
    isTOD = false;
    document.getElementById('todFields').classList.add('hidden');
    await Promise.all([
      loadCSV('tariff_domestic_telescopic.csv', parseSlabs),
      loadCSV('charges_domestic.csv', parseCharges)
    ]);
  }
}

document.getElementById('billForm').addEventListener('submit', async function (e) {
  e.preventDefault();
  debugLog = [];

  const connectionType = document.getElementById('connectionType').value;
  const phaseType = document.getElementById('phaseType').value;
  const importUnits = parseFloat(document.getElementById('importUnits').value);
  const exportUnits = parseFloat(document.getElementById('exportUnits').value);
  const Solar = parseFloat(document.getElementById('Solar').value) || 0;
  const ownSolarDay = Solar - exportUnits;
  const totalUnits = importUnits + ownSolarDay;

  await setupBilling(importUnits);

  const meterInfo = getMeterRent(connectionType, phaseType);
  const meterCharge = meterInfo.value;
  const fixedInfo = getFixedCharge(phaseType, totalUnits);
  const fixedCharge = fixedInfo.value;
  const fixedLabel = fixedInfo.label;
  const fixedChargeStr = getFixedChargeString(importUnits, ownSolarDay);

  let netUnits = Math.max(importUnits - exportUnits, 0);
  let energyCharge = 0;
  let day = 0, peak = 0, offpeak = 0;
  let adjDay = 0, adjPeak = 0, adjOffpeak = 0;

  if (isTOD) {
    day = parseFloat(document.getElementById('todDay').value) || 0;
    peak = parseFloat(document.getElementById('todPeak').value) || 0;
    offpeak = parseFloat(document.getElementById('todOffpeak').value) || 0;

    const sumTOD = day + peak + offpeak;
    if (sumTOD !== importUnits) {
      alert(`TOD units must total ${importUnits} units.`);
      return;
    }

    let remainingExport = exportUnits;
    adjDay = Math.max(0, day - remainingExport);
    remainingExport = Math.max(0, remainingExport - day);
    adjOffpeak = Math.max(0, offpeak - remainingExport);
    remainingExport = Math.max(0, remainingExport - offpeak);
    adjPeak = Math.max(0, peak - remainingExport);

    energyCharge = calculateTODCharge(adjDay, adjPeak, adjOffpeak);
  } else {
    energyCharge = calculateDomesticCharge(netUnits);
  }

  const total = energyCharge + fixedCharge + meterCharge;
  const EChargeString = isTOD
    ? getTODCalculationString(adjDay, adjPeak, adjOffpeak)
    : calculateDomesticChargeString(netUnits);

  // Consumer Bill Calculation (if not a prosumer)
  const consumerImport = importUnits + ownSolarDay;
  await setupBilling(consumerImport);

  let consumerEnergy = 0, consumerFixed = 0, consumerMeter = 0;
  let consumerMsg = "", consumerEString = "";

  const consumerMeterInfo = getMeterRent(connectionType, phaseType);
  consumerMeter = consumerMeterInfo.value;
  const consumerFixedInfo = getFixedCharge(phaseType, consumerImport);
  consumerFixed = consumerFixedInfo.value;

  if (consumerImport > 250) {
    const hasTODInput = document.getElementById('todDay').value !== "";
    if (!hasTODInput) {
      consumerMsg = `<span style="color:red;">To calculate as a Consumer (non-Prosumer), please provide TOD readings for total units: ${consumerImport} (including solar usage).</span>`;
    } else {
      const d = parseFloat(document.getElementById('todDay').value) || 0;
      const p = parseFloat(document.getElementById('todPeak').value) || 0;
      const op = parseFloat(document.getElementById('todOffpeak').value) || 0;
      const dayTotal = d + ownSolarDay;

      consumerEnergy = calculateTODCharge(dayTotal, p, op);
      consumerEString = getTODCalculationString(dayTotal, p, op);
    }
  } else {
    consumerEnergy = calculateDomesticCharge(consumerImport);
    consumerEString = calculateDomesticChargeString(consumerImport);
  }

  const consumerTotal = consumerEnergy + consumerFixed + consumerMeter;

  // Display Results
  const resultDiv = document.getElementById('result');
  resultDiv.style.display = 'block';
  resultDiv.innerHTML = `
    <h3>Prosumer Bill</h3>
    <strong>Billing Type:</strong> ${connectionType}, ${isTOD ? 'TOD' : 'Non-TOD'}<br>
    Own Consumption from Solar during Day time [OC]: ${ownSolarDay}<br>
    ${isTOD ? `Adjusted TOD Units: D: ${adjDay}, P: ${adjPeak}, OP: ${adjOffpeak}<br>` : `Units Billed: ${netUnits}<br>`}
    Energy Charge: ₹${energyCharge.toFixed(2)}<br>
    <span style="font-size: smaller; color: gray;">(${EChargeString})</span><br>
    Fixed Charge: ₹${fixedCharge.toFixed(2)} <span style="font-size: smaller;">(${fixedChargeStr}, ${fixedLabel} slab)</span><br>
    Meter Rent: ₹${meterCharge.toFixed(2)} <span style="font-size: smaller;">(${meterInfo.label})</span><br>
    <b>Total Bill (as a prosumer): ₹${total.toFixed(2)}</b><br><hr>

    <h3>As a Consumer (without Solar Export)</h3>
    Total Units Consumed [I+OC]: ${consumerImport}<br>
    ${consumerMsg || `
      Energy Charge: ₹${consumerEnergy.toFixed(2)}<br>
      <span style="font-size: smaller; color: gray;">(${consumerEString})</span><br>
      Fixed Charge: ₹${consumerFixed.toFixed(2)} <span style="font-size: smaller;">(${fixedChargeStr}, ${fixedLabel} slab)</span><br>
      Meter Rent: ₹${consumerMeter.toFixed(2)} <span style="font-size: smaller;">(${meterInfo.label})</span><br>
      <b>Total Bill (as a consumer): ₹${consumerTotal.toFixed(2)}</b><br>
    `}
  `;

  resultDiv.scrollIntoView({ behavior: 'smooth' });
});
</script>

</body>
</html>

